% Opcje klasy 'iithesis' opisane sa w komentarzach w pliku klasy. Za ich pomoca
% ustawia sie przede wszystkim jezyk oraz rodzaj (lic/inz/mgr) pracy.
\documentclass[english, shortabstract]{iithesis}

\usepackage[utf8]{inputenc}

%%%%% DANE DO STRONY TYTUŁOWEJ
% Niezaleznie od jezyka pracy wybranego w opcjach klasy, tytul i streszczenie
% pracy nalezy podac zarowno w jezyku polskim, jak i angielskim.
% Pamietaj o madrym (zgodnym z logicznym rozbiorem zdania oraz estetyka) recznym
% zlamaniu wierszy w temacie pracy, zwlaszcza tego w jezyku pracy. Uzyj do tego
% polecenia \fmlinebreak.
\polishtitle    {Wymagający złamania wierszy\fmlinebreak tytuł pracy w~języku polskim}
\englishtitle   {English title}
\polishabstract {\ldots}
\englishabstract{\ldots}
% w pracach wielu autorow nazwiska mozna oddzielic poleceniem \and
\author         {Maksymilian Debeściak}
% w przypadku kilku promotorow, lub koniecznosci podania ich afiliacji, linie
% w ponizszym poleceniu mozna zlamac poleceniem \fmlinebreak
\advisor        {dr Jan Kowalski}
%\date          {}                     % Data zlozenia pracy
% Dane do oswiadczenia o autorskim wykonaniu
%\transcriptnum {}                     % Numer indeksu
%\advisorgen    {dr. Jana Kowalskiego} % Nazwisko promotora w dopelniaczu
%%%%%

%%%%% WLASNE DODATKOWE PAKIETY
%
% \usepackage{graphicx,listings,amsmath,amssymb,amsthm,amsfonts,tikz}
\usepackage{graphicx,listings, amsmath, amssymb, amsthm, amsfonts}
%
%%%%% WŁASNE DEFINICJE I POLECENIA
%
\theoremstyle{definition} \newtheorem{definition}{Definition}[chapter]
\theoremstyle{remark} \newtheorem{remark}[definition]{Observation}
\theoremstyle{plain} \newtheorem{theorem}[definition]{Theorem}
\theoremstyle{plain} \newtheorem{lemma}[definition]{Lemma}
% \renewcommand \qedsymbol {\ensuremath{\square}}
% ...
%%%%%

\begin{document}

%%%%% POCZĄTEK ZASADNICZEGO TEKSTU PRACY

\chapter{Introduction}
TODO: more

Guarded-Fragment was introduced in \cite{?} and has been studied since. Its satisfiability problem is $2-Exp-Time$ complete \cite{Gradel1997}).
In \cite{BBE, jelia2021} authors introduce a restriction of the Guarded-Fragment inspired by the Fluted-Fragment (\cite{Fluted}) called Forward-Guarded-Fragment ($FGF$) enjoying $Exp-Time$ complexity for the satisfiability problem and the tree-model property. 
(opcjonalne)The following algorithm deciding satisfiability is though of little practicality, as the proof makes use of the $APSpace$ class.
Later it was discovered (\cite{?}) that $FGF$ reduces to modal logic (\cite{modal logic}) with a non-deterministic polynomial time reduction(???). 
\par In \cite{resolution-gf} authors show how to decide GF with resolution. Here we adapt their work for FGF.
We rely on their proof for completeness, but derive new complexity bound. We also provide the implementation.

\chapter{The Forward-Guarded-Fragment}

The Forward-Guarded-Fragment is a restriction of the Guarded-Fragment to formulas where variables of atomic formulas are infixes of the series of quantified variables. 
\begin{definition}
Let's define the Guarded-Fragment (GF) as the smallest subset of first order logic satisfying:
\begin{enumerate}
    \item Atomic formulas without functional symbols are in GF
    \item GF is closed under use of logical connectives
    \item If $\phi(\bar{x}, \bar{y}) \in GF$ where $\bar{x}, \bar{y}$ are all the free variables of $\phi$ and formula $\alpha(\bar{x},\bar{y})$ is an atom
then also $\exists_{\bar{x}} \alpha(\bar{x}, \bar{y}) \land \phi(\bar{x}, \bar{y}) \in GF$ and $\forall_{\bar{x}} \alpha(\bar{x}, \bar{y}) \rightarrow \phi(\bar{x}, \bar{y}) \in GF$
\end{enumerate}
\end{definition}
\begin{definition}
To define the Forward-Fragment let's first fix a sequence of variables: $x_1, x_2, \dots$. The Forward-Fragment (FF) is then the smallest subset of first order logic satisfying:
\begin{enumerate}
    \item Atomic formulas of form $R(x_i, x_{i+1},\dots,x_{j})$, that is atoms whose variables in order are infixes (without gaps) of the above sequence are in FF
    \item FF is closed under use of logical connectives
    \item If $\phi(x_1,\dots, x_{n}) \in FF$ then also $\exists_{\bar{x_{n}}} \phi(x_1,\dots, x_{n}) \in FF$ and $\forall_{x_n} \phi(x_1,\dots, x_{n}) \in FF$
\end{enumerate}
\end{definition}
So we use the fixed sequence of variables as the order of quantification. The literals in a formula use infixes of the quantified sequence.
\begin{definition}
The Forward-Guarded-Fragment (FGF) is the intersection of the Guarded-Fragment and the Forward-Fragment.
\end{definition}

\section{Problem definition}

The goal is to describe a resolution based procedure deciding the Forward-Guarded-Fragment.
The algorithm should take FGF formula as an input and return true or false based on whether the formula is satisfiable.

\begin{definition}
A first order logic formula is called $satisfiable$ if there exist a model where the formula gets interpreted as true.
\end{definition}

Resolution procedure calculates a set of clauses following from the initial formula.
An empty clause - a contradiction - gets derived for unsatisfiable formulas. 
Then a syntactic proof of the negation of the input formula could be derived from the resolution process.
The process for arbitrary first order formulas may not terminate.
For the Guarded-Fragment though, it has been shown in \cite{resolution GF}, that the production of new clauses saturates
and when it does, the model where formula holds can be derived from the saturation.
For FGF, which is of our interest, the saturation is achieved quicker.
We will need a flavour of resolution called ordered resolution, which enforces an order in which new clauses get derived.

\chapter{Prerequisities}
TODO: maybe avoid this chapter and inline definitions before their first use
\begin{definition}
    TODO: define VarDepth
\end{definition}

TODO: put normalization here

\chapter{Resolution procedure}

We will repeat the procedure from \cite{resolution gf}. As FGF is a subset of GF, it can be applied for FGF as well.
The only modification is that we specifically say which most general unifier is used at the unification step.

\section{Order}
We repeat the order on literals from \cite{resolution gf}.
\begin{definition}
Define the following order $\sqsubset$ on literals.
\begin{enumerate}
    \item $A \subseteq B$ if $Vardepth(A) < Vardepth(B)$, or
    \item $A \sqsubset B$ if $Var(A) \subseteq Var(B)$.
\end{enumerate}
\end{definition}
Eventhough not an order on the set of arbitrary literals it is an order among literals from a single guarded clause as taking part in the resolution.
For a proof see \cite{resolution gf}.

\chapter{Clausification}

We will describe a sequence of transformations going from formulas in FGF to formulas in CNF for use in resolution. 
The transformations are standard for first order logic and preserve satisfiability.
\begin{itemize}
    \item $NNF$ is the transformation to negation normal form (NNF).
    \item $Struct_{\forall}$ is transformation applied to formulas in NNF returning a set of formulas of form $\forall_{\bar{x}}\phi(\bar{x})$ where $\phi$ is already without universal quantifiers. The conjunction of formulas from the resulting set is equisatisfiable with the initial formula.
    \item $Skolemization$ is the satisfiability-preserving transformation removing all existential quantifiers and replacing the respective quantified variables with fresh functional terms.
    We apply it to every formula in the set resulting from $Struct_\forall$ transformation.
    Note that then every existential quantifier is in the scope of the same single universal quantifier.
    We'll use specific fresh functional symbols for the skolem terms for ease of proof
    \item $Clausification$ yields a formula in CNF. We represent it as a set of clauses and make the universal quantification implicit for all the free variables. 
\end{itemize}
TODO: better description, connect with the implementation
\begin{definition}
    Let $CNF$ be a function from the set of FGF formulas to the set of conjunctive sets of clauses obtained by sequencing above transformations.
\end{definition}

\section{Ordered Resolution}
TODO: repeat how resolution works

\subsection{Most general unifier}
Any renaming substitution composed with the most general unifier is also a most general unifier.
We want to choose which unifier gets used. TODO


% \section{Guardness}

% We rely strongly on the results from \cite{nivelle}. We need their definition of guardness:
% \begin{definition}
% A clause c is called guarded if it satisfies the following conditions:
%     \begin{enumerate}
%     \item Every non-ground, functional term in c contains all variables of c.
%     \item If c is not ground, then there is a negative literal ¬A in c that does not contain a
%     non-ground, functional term, and that contains all variables of c.
%     \end{enumerate}
% \end{definition}
% A clause set C is called guarded if its clauses are guarded.

% \begin{lemma}
    
% \end{lemma}

\chapter{Completeness}

follows from \cite{resolution gf}. TODO: repeat the argument

\chapter{Complexity}

\section{Normalization}
We observe that in the unifications of the clauses resulting from FGF formulas it is always possible to reuse variables from just one of the unified terms.
That way keeping the variable names close to original. The exact statement is formulated by lemma.TODO. 
For the lemma we will use a normalization of clauses obtained by variable renamings.

\begin{definition}
We call $normalization$ of a literal, a literal obtained by the following renaming:
\begin{enumerate}
    \item Order variable occurences lexicographically on $(-depth, index)$ 
    where $depth$ is the depth at which a position of the variable occurs and index is a position from left where the variable occurs when literal is written in standard notation.
    \item Greedly assign variables $x_1, x_2, \dots$ in order
\end{enumerate}
\end{definition}

Such a definition is convienient as normalization is now well defined on all formulas. 
The procedure may seem convoluted, but the actual terms obtained during resolution have a simple form, which is subject of Lemma.TODO.

\section{Forwardness}

For ease of proof, we will fix a concrete procedure for naming fresh functional symbols used in skolemization. 
Namely for variables quantified by $\exists_{x_n}$ we substitute skolem terms $x^\alpha_n(x_1, \dots, x_{k})$ where 
for $\alpha$ we choose fresh symbols differentiating between variables coming from seperate quantifiers.

We will write $\bar{x}_{i..j}$ for the gap-free sequence of variables $x_i, x_{i+1}, \dots, x_j$ and 
$\bar{x}^{\bar{\alpha}}_{j..k}(\bar{x}_{1..i})$ for the gap-free sequence of skolem terms $x^{\alpha_j}_{j}(\bar{x}_{1..i}), x^{\alpha_{j+1}}_{j+1}(\bar{x}_{1..i}), \dots, x^{\alpha_k}_k(\bar{x}_{1..i})$.

\begin{definition}
We call a literal $forward$ if it is ground or it is of form
$$(\lnot)R(\bar{x}_{i..j}, \bar{x}^{\bar{\alpha}}_{{j+1..k}}(\bar{x}_{1..j}))$$
for some relational symbol $R$ and sequence $\bar{\alpha}$. Variable or skolem term sequences may be empty.
\end{definition}

We will call a clause $forward$ if its literals are $forward$. $Forward$ clauses are already normalized.

\begin{lemma}
If $\phi \in FGF$ then $CNF(\phi)$ contains only $forward$ clauses.
\end{lemma}

\begin{proof}
TODO
\end{proof}

% \begin{lemma}\ \\
\begin{lemma}
\begin{enumerate}
    \item If $c_1$, $c_2$ are $forward$ clauses and $c$ is ordered resolvent of $c_1$ and $c_2$, then $c$ is forward.
    \item If $c_1$ is $forward$ clause and $c$ is a factor of $c_1$, then $c$ is $forward$.  
\end{enumerate}
\end{lemma}

\begin{proof}
\par We consider resolution first. Let $c_1$, $c_2$ be $forward$ clauses and $c$ be their ordered resolvent.
% Let $R$,$Q$ be the possibly negated relational symbols of $c_1$, $c_2$ respectively, that is $\{R, Q\}=\{P, \lnot P\}$ for some P.
Without loss of generality let $c_1$ be the positive literal. \_\_\_\_\_
Then $c_1=R(\bar{x}_{k..l}, \bar{x}^{\bar{\alpha}}_{{l+1..m}}(\bar{x}_{1..l}))$
and $c_2=\lnot R(\bar{x}_{k+s..o}, \bar{x}^{\bar{\alpha'}}_{{o+1..m+s}}(\bar{x}_{1..o}))$ for some $k,l,m,o\in \mathbb{N}$ and $s\in \mathbb{Z}$.
We denoted by $k, m$ the interval of indices appearing in $c_1$, by $s$ the shift compared to $c_2$.
Then $l, o$ mark index where the sequence of variables turns into sequence of skolem terms, in $c_1$ and $c_2$ respectively.
Let's also assume that in $c_1$ the prefix of variables $\bar{x}_{i..j}$
is no shorter than in $c_2$, that is $l-k\geq o-(k+s)$. Two assumptions can be both made without loss of generality as
the sign of literals doesn't impact the unifier.
To calculate the most general unifier let's rename variables of $c_1$: $x_i \rightarrow y_i $.
% $$R(y_i, y_{i+1}, \dots, y_{i+j'-i'}, y_{i+j'-i'+1},\dots, y_j, x_{j+1}(\bar{x}_{1..j}), \dots, x_{k}(\bar{x}_{1..j}))\newline
% \doteq
% \newline\lnot R(x_i', x_{i'+1}, \dots, x_{j'}, x_{j'+1}(\bar{x}_{1..j'}), \dots, x_{i'+j-i}(\bar{x}_{1..j'}), x_{i'+j-i+1}(\bar{x}_{1..j'}), \dots, x_{k'}(\bar{x}_{1..j'}))$$
% \begin{equation*}
% \begin{split}
% \begin{align*}
% &R(&y_i&, &y_{i+1}&, \dots, &y_{i+j'-i'}&, &y_{i+j'-i'+1}&,\dots, &y_j&, &x_{j+1}(\bar{x}_{1..j})&, \dots, &x_{k}(\bar{x}_{1..j})&) \\
% \doteq
% \lnot &R(&x_i'&, &x_{i'+1}&, \dots, &x_{j'}&, &x_{j'+1}(\bar{x}_{1..j'})&, \dots, &x_{i'+j-i}(\bar{x}_{1..j'})&, &x_{i'+j-i+1}(\bar{x}_{1..j'})&, \dots, &x_{k'}(\bar{x}_{1..j'})&)
% \end{align*}

% $i'-i=m$
\begin{align*}
      &R(&y_i&,     &y_{i+1}&,   \dots, &y_{j'-m}&,    &y_{j'-m+1}&,\dots,                 &y_j&,                      &x_{j+1}(\bar{x}_{1..j})&, \dots,    &x_{k}(\bar{x}_{1..j})&) \\
    \doteq
\lnot &R(&x_{i+m}&, &x_{i+m+1}&, \dots, &x_{j'}&,      &x_{j'+1}(\bar{x}_{1..j'})&, \dots, &x_{j+m}(\bar{x}_{1..j'})&, &x_{j+m+1}(\bar{x}_{1..j'})&, \dots, &x_{k+m}(\bar{x}_{1..j'})&)
\end{align*}
% \end{split}
% \end{equation*}
Comparing the terms we get 3 types of equations:
\begin{enumerate}
    \item $y_s\doteq x_{s+m}$ for $s=i,\dots, j'-m$
    \item $y_s\doteq x_{s+m}(\bar{x}_{1..j'})$ for $s=j'-m+1,\dots, j$
    \item $x_{s}(\bar{x}_{1..j})\doteq x_{s+m}(\bar{x}_{1..j'})$ for $s=j+1,\dots, k$
\end{enumerate}
\end{proof}
Every mgu of $c_1$, $c_2$ satisfies the equations, as renamings TODO .
When there are any equations of type 3 and there is mgu, then
necessarily TODO. 

\chapter{Implementation}



%%%%% BIBLIOGRAFIA

% \begin{thebibliography}{1}
%     Grädel, E., Kolaitis, P., Vardi, M., 1997. On the decision problem for two-variable first-order logic.
% Bull. Symb. Logic 3, 53–69
% \end{thebibliography}

\end{document}
