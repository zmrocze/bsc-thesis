% Opcje klasy 'iithesis' opisane sa w komentarzach w pliku klasy. Za ich pomoca
% ustawia sie przede wszystkim jezyk oraz rodzaj (lic/inz/mgr) pracy.
\documentclass[english, shortabstract]{iithesis}

\usepackage[utf8]{inputenc}

%%%%% DANE DO STRONY TYTUŁOWEJ
% Niezaleznie od jezyka pracy wybranego w opcjach klasy, tytul i streszczenie
% pracy nalezy podac zarowno w jezyku polskim, jak i angielskim.
% Pamietaj o madrym (zgodnym z logicznym rozbiorem zdania oraz estetyka) recznym
% zlamaniu wierszy w temacie pracy, zwlaszcza tego w jezyku pracy. Uzyj do tego
% polecenia \fmlinebreak.
\polishtitle    {Wymagający złamania wierszy\fmlinebreak tytuł pracy w~języku polskim}
\englishtitle   {English title}
\polishabstract {\ldots}
\englishabstract{\ldots}
% w pracach wielu autorow nazwiska mozna oddzielic poleceniem \and
\author         {Maksymilian Debeściak}
% w przypadku kilku promotorow, lub koniecznosci podania ich afiliacji, linie
% w ponizszym poleceniu mozna zlamac poleceniem \fmlinebreak
\advisor        {dr Jan Kowalski}
%\date          {}                     % Data zlozenia pracy
% Dane do oswiadczenia o autorskim wykonaniu
%\transcriptnum {}                     % Numer indeksu
%\advisorgen    {dr. Jana Kowalskiego} % Nazwisko promotora w dopelniaczu
%%%%%

%%%%% WLASNE DODATKOWE PAKIETY
%
% \usepackage{graphicx,listings,amsmath,amssymb,amsthm,amsfonts,tikz}
\usepackage{graphicx,listings, amsmath, amssymb, amsthm, amsfonts}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}
%
%%%%% WŁASNE DEFINICJE I POLECENIA
%
\theoremstyle{definition} \newtheorem{definition}{Definition}[chapter]
\theoremstyle{remark} \newtheorem{remark}[definition]{Observation}
\theoremstyle{plain} \newtheorem{theorem}[definition]{Theorem}
\theoremstyle{plain} \newtheorem{lemma}[definition]{Lemma}
% \renewcommand \qedsymbol {\ensuremath{\square}}
% ...
%%%%%

\begin{document}

%%%%% POCZĄTEK ZASADNICZEGO TEKSTU PRACY

\chapter{Introduction}
TODO: more

Guarded-Fragment was introduced in \cite{?} and has been studied since. Its satisfiability problem is $2-Exp-Time$ complete \cite{Gradel1997}).
In \cite{BBE, jelia2021} authors introduce a restriction of the Guarded-Fragment inspired by the Fluted-Fragment (\cite{Fluted}) called Forward-Guarded-Fragment ($FGF$) enjoying $Exp-Time$ complexity for the satisfiability problem and the tree-model property. 
(opcjonalne)The following algorithm deciding satisfiability is though of little practicality, as the proof makes use of the $APSpace$ class.
Later it was discovered (\cite{?}) that $FGF$ reduces to modal logic (\cite{modal logic}) with a non-deterministic polynomial time reduction(???). 
\par In \cite{resolution-gf} authors show how to decide GF with resolution. Here we adapt their work for FGF.
We rely on their proof for completeness, but derive new complexity bound. We also provide the implementation.

\chapter{The Forward-Guarded-Fragment}

The Forward-Guarded-Fragment is a restriction of the Guarded-Fragment to formulas where variables of atomic formulas are infixes of the series of quantified variables. 
\begin{definition}
Let's define the Guarded-Fragment (GF) as the smallest subset of first order logic satisfying:
\begin{enumerate}
    \item Atomic formulas without functional symbols are in GF
    \item GF is closed under use of logical connectives
    \item If $\phi(\bar{x}, \bar{y}) \in GF$ where $\bar{x}, \bar{y}$ are all the free variables of $\phi$ and formula $\alpha(\bar{x},\bar{y})$ is an atom
then also $\exists_{\bar{x}} \alpha(\bar{x}, \bar{y}) \land \phi(\bar{x}, \bar{y}) \in GF$ and $\forall_{\bar{x}} \alpha(\bar{x}, \bar{y}) \rightarrow \phi(\bar{x}, \bar{y}) \in GF$
\end{enumerate}
\end{definition}
\begin{definition}
To define the Forward-Fragment let's first fix a sequence of variables: $x_1, x_2, \dots$. The Forward-Fragment (FF) is then the smallest subset of first order logic satisfying:
\begin{enumerate}
    \item Atomic formulas of form $R(x_i, x_{i+1},\dots,x_{j})$, that is atoms whose variables in order are infixes (without gaps) of the above sequence are in FF
    \item FF is closed under use of logical connectives
    \item If $\phi(x_1,\dots, x_{n}) \in FF$ then also $\exists_{\bar{x_{n}}} \phi(x_1,\dots, x_{n}) \in FF$ and $\forall_{x_n} \phi(x_1,\dots, x_{n}) \in FF$
\end{enumerate}
\end{definition}
So we use the fixed sequence of variables as the order of quantification. The literals in a formula use infixes of the quantified sequence.
\begin{definition}
The Forward-Guarded-Fragment (FGF) is the intersection of the Guarded-Fragment and the Forward-Fragment.
\end{definition}

\section{Problem definition}

The goal is to describe a resolution based procedure deciding the Forward-Guarded-Fragment.
The algorithm should take FGF sentence as an input and return true or false based on whether the sentence is satisfiable.

\begin{definition}
A first order logic formula is called $satisfiable$ if there exist a model where the formula gets interpreted as true.
\end{definition}

Resolution procedure calculates a set of clauses following from the initial formula.
An empty clause - a contradiction - gets derived for unsatisfiable formulas. 
Then a syntactic proof of the negation of the input formula could be derived from the resolution process.
The process for arbitrary first order formulas may not terminate.
For the Guarded-Fragment though, it has been shown in \cite{resolution GF}, that the production of new clauses saturates
and when it does, the model where formula holds can be derived from the saturation.
For FGF, which is of our interest, the saturation is achieved quicker.
We will need a flavour of resolution called ordered resolution, which restricts which inferences are allowed.

\chapter{Prerequisities}
We repeat the following lemma from \cite{resolution GF}.
\begin{lemma}
Every guarded clause c has a $\sqsubset$-maximal literal, and every maximal literal
of c contains all variables of c.
\end{lemma}
For proof see Lemma 3.7 in \cite{resolution GF}.

TODO: maybe avoid this chapter and inline definitions before their first use
\begin{definition}
    TODO: define VarDepth
\end{definition}

TODO: put normalization here

\chapter{Resolution procedure}

We will repeat the procedure from \cite{resolution gf}. As FGF is a subset of GF, it can be applied for FGF as well.
The only modification is that we specifically say which most general unifier is used at the unification step.

\section{Procedure overview}

First a formula needs to be translated to CNF form, that is conjunction of clauses of literals. 
We represent a CNF formula as a set of clauses. The transformed formula is a starting point to the resolution procedure.
Resolution iterates on the set of clauses, inspecting pairs of clauses for possible inferences.
There is two ways to make an inference: resolution and factoring, described in section \textit{Inference}.
When an inference is made a new clause gets added to the set.
Thus in the process the set grows containing increasingly more clauses following from the initial formula.
When an empty clause gets derived, it proves unsatisfiability of the initial sentence.
Otherwise the process stops after no new clauses can be derived. If the resulting 
clause set contains no empty clauses, the initial formula is satisfiable.

\section{Clausification}

We will describe a sequence of transformations going from formulas in FGF to formulas in CNF.
The transformations are standard for first order logic and preserve satisfiability.
\begin{enumerate}
    \item First $NNF$ is the transformation to negation normal form (NNF). See \cite{resolution book} Section 2.2 for description.
    \item $Struct_{\forall}$ is the transformation applied to formulas in NNF returning a set of formulas of form $\forall_{\bar{x}}\phi(\bar{x})$ where $\phi$ is already without universal quantifiers. The conjunction of formulas from the resulting set is equisatisfiable with the initial formula.
    It works, by repeatedly replacing sub-formulas of form $\forall_{\bar{y}} \psi(\bar{x},\bar{y})$ 
    by fresh atoms $\alpha(\bar{x})$ and adding a defining formula $\forall_{\bar{x}} \alpha \rightarrow \forall_{\bar{y}} \psi(\bar{x},\bar{y})$.
    The transformation preserves satisfiability only, due to the one way implication in the defining formula.
    \item $Skolemization$ is the satisfiability-preserving transformation removing all existential quantifiers and replacing the respective quantified variables with fresh functional terms.
    We apply it to every formula in the set resulting from $Struct_\forall$ transformation.
    Note that then every existential quantifier is in the scope of the same universal quantifiers.
    \item Finally $clausification$ yields a formula in CNF by treating th formulas under universal quantifiers as propositional logic sentences. We represent it as a set of clauses and make the universal quantification implicit for all the free variables. 
\end{enumerate}

For definitions of the transformations 2,3,4 check definitions 2.6, 2.7, 2.8 respectively in \cite{resolution GF}

For ease of proof we will use concrete procedure for naming fresh functional symbols for the skolem terms.
Namely when quantifier $\exists_{x_i}$ gets removed, we substitute term $x_i^{\alpha}(\bar{x_{1..j}})$ for the variable it bound, 
where $\alpha$ is a fresh symbol differentiating between variables bounded by other quantifiers $\exists_{x_i}$ and $\bar{x_{1..j}}$ is the sequence of universally quantified variables in scope.

\begin{definition}
    Let $CNF$ be a function from the set of FGF formulas to the set of conjunctive sets of clauses obtained by sequencing above transformations.
\end{definition}

\subsection{Order}

We repeat the order on literals from \cite{resolution gf}.
\begin{definition}
Define the following order $\sqsubset$ on literals.
\begin{enumerate}
    \item $A \subseteq B$ if $Vardepth(A) < Vardepth(B)$, or
    \item $A \sqsubset B$ if $Var(A) \subseteq Var(B)$.
\end{enumerate}
\end{definition}
Eventhough not an order on the set of arbitrary literals it is an order among literals from a single guarded clause as taking part in the resolution.
For a proof see \cite{resolution gf}.


\section{Ordered Resolution}
TODO: repeat how resolution works

\subsection{Most general unifier}
Any renaming substitution composed with the most general unifier is also a most general unifier.
We want to choose which unifier gets used. TODO

\section{Full algorithm}

\begin{algorithm}
\begin{algorithmic}
\Procedure{SAT}{$\phi$}
\State $C \gets CNF(\phi)$
\State $continue \gets True$
\While{continue}
\State $continue \gets False$
\For{$c_1, c_2 \in C \times C$}
\If{$c_1, c_2$ resolve into $c$}
    \State $C \gets C \cup \{c\}$
    \State $continue \gets True$
\EndIf
\If{$c_1$ factors into $c$}
    \State $C \gets C \cup \{c\}$
    \State $continue \gets True$
\EndIf
\EndFor
\EndWhile
\State
\Return $\{\} \stackrel{?}{\in} C$
\EndProcedure
\end{algorithmic}
\end{algorithm}

This is the algorithm from \cite{resolution GF} and its termination and correctness is proved by Theorem 3.20.
Termination also follows from our argument in section on complexity.

% \section{Guardness}

% We rely strongly on the results from \cite{nivelle}. We need their definition of guardness:
% \begin{definition}
% A clause c is called guarded if it satisfies the following conditions:
%     \begin{enumerate}
%     \item Every non-ground, functional term in c contains all variables of c.
%     \item If c is not ground, then there is a negative literal ¬A in c that does not contain a
%     non-ground, functional term, and that contains all variables of c.
%     \end{enumerate}
% \end{definition}
% A clause set C is called guarded if its clauses are guarded.

% \begin{lemma}
    
% \end{lemma}

\chapter{Completeness}

follows from \cite{resolution gf}. TODO: repeat the argument

\chapter{Complexity}

\section{Normalization}
We observe that in the unifications of the clauses resulting from FGF formulas it is always possible to reuse variables from just one of the unified terms.
That way keeping the variable names close to original. The exact statement is formulated by lemma.TODO. 
For the lemma we will use a normalization of clauses obtained by variable renamings.

\begin{definition}
We call $normalization$ of a literal, a literal obtained by the following renaming:
\begin{enumerate}
    \item Order variable occurences lexicographically on $(-depth, index)$ 
    where $depth$ is the depth at which a position of the variable occurs and index is a position from left where the variable occurs when literal is written in standard notation.
    \item Greedly assign variables $x_1, x_2, \dots$ in order
\end{enumerate}
\end{definition}

Such a definition is convienient as normalization is now well defined on all formulas. 
The procedure may seem convoluted, but the actual terms obtained during resolution have a simple form, which is subject of Lemma.TODO.

\section{Forwardness}

For ease of proof, we will fix a concrete procedure for naming fresh functional symbols used in skolemization. 
Namely for variables quantified by $\exists_{x_n}$ we substitute skolem terms $x^\alpha_n(x_1, \dots, x_{k})$ where 
for $\alpha$ we choose fresh symbols differentiating between variables coming from seperate quantifiers.

We will write $\bar{x}_{i..j}$ for the gap-free sequence of variables $x_i, x_{i+1}, \dots, x_j$ and 
$\bar{x}^{\bar{\alpha}}_{j..k}(\bar{x}_{1..i})$ for the gap-free sequence of skolem terms $x^{\alpha_j}_{j}(\bar{x}_{1..i}), x^{\alpha_{j+1}}_{j+1}(\bar{x}_{1..i}), \dots, x^{\alpha_k}_k(\bar{x}_{1..i})$.

\begin{definition}
We call a literal $forward$ if it is of form
$$(\lnot)R(\bar{x}_{i..j}, \bar{x}^{\bar{\alpha}}_{{j+1..k}}(\bar{x}_{1..j}))$$
for some relational symbol $R$ and sequence $\bar{\alpha}$. This includes ground literals. Variable or skolem term sequences may be empty.
\end{definition}

We will call a clause $forward$ if its literals are $forward$. $Forward$ clauses are already normalized.

\begin{lemma}
If $\phi \in FGF$ then $CNF(\phi)$ contains only $forward$ clauses.
\end{lemma}

\begin{proof}
TODO
\end{proof}

% \begin{lemma}\ \\
\begin{lemma}
\begin{enumerate}
    \item If $c_1$, $c_2$ are $forward$ clauses and $c$ is ordered resolvent of $c_1$ and $c_2$, then $c$ is forward.
    \item If $c_1$ is $forward$ clause and $c$ is a factor of $c_1$, then $c$ is $forward$.  
\end{enumerate}
\end{lemma}

\begin{proof}
\par We consider resolution first. Let $c_1$, $c_2$ be $forward$ clauses and $c$ be their ordered resolvent.
Let $A\in c_1$ and $B\in c_2$ be the literals resolved upon.
Without loss of generality let $A$ be the positive literal.
Then $c_1=R(\bar{x}_{k..l}, \bar{x}^{\bar{\alpha}}_{{l+1..m}}(\bar{x}_{1..l}))$
and $c_2=\lnot R(\bar{x}_{k+s..o}, \bar{x}^{\bar{\alpha'}}_{{o+1..m+s}}(\bar{x}_{1..o}))$ for some $k,l,m,o\in \mathbb{N}$ and $s\in \mathbb{Z}$.
We denoted by $k, m$ the interval of indices appearing in $c_1$, by $s$ the shift compared to $c_2$.
Then $l, o$ mark index where the sequence of variables turns into sequence of skolem terms, in $c_1$ and $c_2$ respectively.
Let's also assume that in $c_1$ the prefix of variables $\bar{x}_{i..j}$
is no shorter than in $c_2$, that is $l-k\geq o-(k+s)$. Two assumptions can be both made without loss of generality as
the sign of literals doesn't impact the unifier.
To calculate the most general unifier let's first rename variables of $c_1$: $x_i \rightarrow y_i$.
The unification problem is:
\begin{align*}
      &R(&y_k&,     &y_{k+1}&,   \dots, &y_{o-s}&,    &y_{o-s+1}&,\dots,                 &y_l&,                      &x_{l+1}(\bar{x}_{1..l})&, \dots, &x_{m}(\bar{x}_{1..l})&) \\
    \doteq
\lnot &R(&x_{k+s}&, &x_{k+s+1}&, \dots, &x_{o}&,      &x_{o+1}(\bar{x}_{1..o})&, \dots, &x_{l+o}(\bar{x}_{1..o})&, &x_{l+o+1}(\bar{x}_{1..o})&, \dots, &x_{m+s}(\bar{x}_{1..o})&)
\end{align*}
Comparing the terms we get 3 types of equations:
\begin{enumerate}
    \item $y_i\doteq x_{i+s}$ for $i=k,\dots, o-s$
    \item $y_i\doteq x_{i+s}(\bar{x}_{1..o})$ for $i=o-s+1,\dots, l$
    \item $x_i(\bar{x}_{1..l})\doteq x_{i+s}(\bar{x}_{1..o})$ for $s=l+1,\dots, m$
\end{enumerate}
\end{proof}
Every mgu of $A$ after our renaming and $B$ satisfies the equations.

If there are any equations of type 3 and there exists a solution, then
necessarily $x_m$ and $x_{m+s}$ are the same functional symbols, so $s=0$. Also $o=l$ as $o$ and $l$ are respective arities of $x_{m}$, $x_{m+s}$.
It follows that the clauses $c_1$, $c_2$ are already unified with identity unification. Every literal in the clause $c$ comes directly from one of $c_1$, $c_2$ so $c$ is $forward$.

Let's consider the other case, when $A$ doesn't contain any functional terms and therefore there are no equations of type 3.
The unification has an easy solution then.% We can then solve the unification problem using variables from $c_2$ in the result.
We will define unifying substitution $\sigma : \{y_k,\dots,y_l, x_1, \dots, x_o\} \rightarrow \{x_1, \dots, x_o\}$.
Let $\sigma$ be the identity substitution on variables $x_1$ to $x_o$.
Equations of type 1 and 2 define the substitution on variables $y_k$ to $y_l$:
\begin{itemize}
    \item $y_i \leftarrow x_{i+s}$ for $i=k,\dots, o-s$
    \item $y_i \leftarrow x_{i+s}(\bar{x}_{1..o})$ for $i=o-s+1,\dots, l$
\end{itemize}
$\sigma$ is trivially a unifier of $A$ after the renaming and $B$, as
$\sigma$ unifies all pairs of relational symbol arguments at matching indices.
Substitution $\sigma$ is the most general unifier, because every unifier more general
has to assign a variable instead of a functional term to one of the variables $y_{o-s+1}$ to $y_l$, 
thus invalidating the corresponding equation. 

$\sigma$ is the substitution used in the resolution procedure, because $A$ is $normalized$ after applying $\sigma$.
Therefore every literal in $c$ is either a literal of $c_2$ and therefore $forward$, or it is 
literal of $c_1$ after applying substitution $\sigma$.
$A$ is a maximal literal in $c_1$, so every other literal in $c_1$ 
\begin{itemize}
    \item doesn't contain functional terms
    \item contains only variables from $A$ by lemma (TODO:lemma number)
\end{itemize}
Therefore every literal in $c_1$ is of form $(\lnot)R(\bar{y}_{i..j})$ for some infix $\bar{y}_{i..j}$ of $\bar{y}_{k..l}$.
After substitution every literal is of form $(\lnot)R(\bar{t})$ for some infix $\bar{t}$ of $\bar{x}_{k+s..o}, \bar{x}_{{o+1..m+s}}(\bar{x}_{1..o})$, therefore is $forward$.

\par Let's consider factoring. Let $c_1$ be a $forward$ clause and $c$ be its factor.
Let $A_1$, $A_2$ be the literals participating in factoring and $A_1$ be the maximal one.
Literal $A_1$ contains all variables of $A_2$ by lemma (TODO:lemma number) and both literals are $forward$. 
It follows that the literals are indentical. $A_1$ is already $normalized$, because it is $forward$.
The factoring substitution is then identity substitution and $c\subset c_1$. So $c$ is forward.

\chapter{Implementation}



%%%%% BIBLIOGRAFIA

% \begin{thebibliography}{1}
%     Grädel, E., Kolaitis, P., Vardi, M., 1997. On the decision problem for two-variable first-order logic.
% Bull. Symb. Logic 3, 53–69
% \end{thebibliography}

\end{document}
